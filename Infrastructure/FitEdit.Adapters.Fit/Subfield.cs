#region Copyright
/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2023 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.115Release
// Tag = production/release/21.115.00-0-gfe0a7f8
/////////////////////////////////////////////////////////////////////////////////////////////

#endregion

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.IO;

namespace Dynastream.Fit
{
  /// <summary>
  /// The Subfield class represents an alternative field definition used
  /// by dynamic fields.  They can only be associated with a containing
  /// field object.
  /// </summary>
  public class Subfield
  {
    #region Internal Classes
    /// <summary>
    /// The SubfieldMap class tracks the reference field/value pairs which indicate a field
    /// should use the alternate subfield definition rather than the usual defn (allows Dynamic Fields)
    /// </summary>
    private class SubfieldMap
    {
      private byte refFieldNum_;
      private object refFieldValue_;

      internal SubfieldMap(byte refFieldNum, object refFieldValue)
      {
        this.refFieldNum_ = refFieldNum;
        this.refFieldValue_ = refFieldValue;
      }

      internal SubfieldMap(SubfieldMap subfieldMap)
      {
        refFieldNum_ = subfieldMap.refFieldNum_;
        refFieldValue_ = subfieldMap.refFieldValue_;
      }

      /// <summary>
      /// Checks if the reference fields in a given message indicate the subfield (alternate)
      /// definition should be used
      /// </summary>
      /// <param name="mesg">message of interest</param>
      /// <returns>true if the subfield is active</returns>
      internal bool CanMesgSupport(Mesg mesg)
      {
        Field field = mesg.GetField(refFieldNum_);

        if (field != null)
        {
          object value = field.GetValue(0, Fit.SubfieldIndexMainField);
          // Float refvalues are not supported
          if (Convert.ToInt64(value) == Convert.ToInt64(refFieldValue_))
          {
            return true;
          }
        }
        return false;
      }
    }
    #endregion Internal Classes

    #region Fields
    private readonly List<SubfieldMap> maps = new();
    #endregion // Fields

    #region Properties
    public string Name { get; } = "unknown";
    public byte Type { get; } = 0;
    public float Scale { get; } = 1f;
    public float Offset { get; } = 0f;
    public string Units { get; } = "";
    public Dictionary<int, FieldComponent> Components { get; } = new();
    #endregion // Properties

    #region Constructors
    internal Subfield(Subfield subfield)
    {
      if (subfield == null)
      {
        return;
      }

      Name = subfield.Name;
      Type = subfield.Type;
      Scale = subfield.Scale;
      Offset = subfield.Offset;
      Units = subfield.Units;

      foreach (SubfieldMap map in subfield.maps)
      {
        maps.Add(new SubfieldMap(map));
      }
      Components = subfield.Components.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    internal Subfield(string name, byte type, float scale, float offset, string units)
    {
      Name = name;
      Type = type;
      Scale = scale;
      Offset = offset;
      Units = units;
    }
    #endregion // Constructors

    #region Methods
    internal void AddMap(byte refFieldNum, object refFieldValue) => maps.Add(new SubfieldMap(refFieldNum, refFieldValue));

    internal void AddComponent(FieldComponent newComponent)
    {
      int index = Components.Count;
      Components[index] = newComponent;
    }

    /// <summary>
    /// Checks if the reference fields in a given message indicate the subfield (alternate)
    /// definition should be used
    /// </summary>
    /// <param name="mesg">message of interest</param>
    /// <returns>true if the subfield is active</returns>
    public bool CanMesgSupport(Mesg mesg)
    {
      foreach (SubfieldMap map in maps)
      {
        if (map.CanMesgSupport(mesg))
        {
          return true;
        }
      }
      return false;
    }
    #endregion // Methods
  } // Class
} // namespace
